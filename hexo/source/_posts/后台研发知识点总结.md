---
title: 后台研发知识点总结
date: 2017-04-08 21:21:44
tags: [Java, 后台, 面试]
categories: 笔记
---

# 后台研发知识点总结

为了准备面试，特此将后台研发相关知识以及在面试中遇到的实际问题总结出来，以供随时复习。

<!--more-->

## Java 基础知识

### Java 数据类型分为？
基本数据类型：int ,float, boolean, char, byte, double, long, short
引用数据类型：类，数组，接口

基本数据类型可以在栈中直接分配内存
引用数据类型则是数据的引用在栈中，其对象在堆中

### 八种基本数据类型？

| 类型      | 字节   |
| :------ | :--- |
| byte    | 1    |
| short   | 2    |
| int     | 4    |
| long    | 8    |
| float   | 4    |
| double  | 8    |
| char    | 2    |
| boolean | 1    |

### String，Stringbuffer，StringBuilder的区别？ 
String：字符串常量
StringBuffer：字符串变量, 线程安全的
StringBuilder：字符串变量, 线程非安全的

三者在执行速度方面的比较：StringBuilder >  StringBuffer  >  String

对于三者使用的总结： 
1. 如果要操作少量的数据用 = String
2. 单线程操作字符串缓冲区 下操作大量数据 = StringBuilder
3. 多线程操作字符串缓冲区 下操作大量数据 = StringBuffer




## JVM 

### 类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序 
1. 父类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行
2. 子类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行
3. 父类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行
4. 父类构造方法
5. 子类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行
6. 子类构造方法
   结论：对象初始化的顺序，先静态方法，再构造方法，每个又是先基类后子类。



## Java 框架



## 操作系统

### 产生死锁的条件？

1. 互斥条件：一个资源同时只能由一个进程占有，不能有两个或者两个以上的占有。
2. 不可抢占条件：在一个进程所获取的资源未使用完毕之前，资源申请者不能强行从资源占有者手中抢占资源。
3. 占有申请条件：进程已经占有了一个资源，但是又需要申请新的资源，但是新申请的资源已经被别的进程占有了，此时，当前进程就会阻塞，但是在获取申请的资源之前，它还会一直占有已占有的那个资源
4. 循环等待条件：存在一个循环等待序列，p1等待p2，p2等待p3， p3等待p1，形成一个进程循环等待。




## 计算机网络

### http1.0和http1.1有什么区别
1. HTTP/1.0协议使用非持久连接,即在非持久连接下,一个tcp连接只传输一个Web对象；
2. HTTP/1.1默认使用持久连接(然而,HTTP/1.1协议的客户机和服务器可以配置成使用非持久连接)。在持久连接下,不必为每个Web对象的传送建立一个新的连接,一个连接中可以传输多个对象.

一个WEB站点每天可能要接收到上百万的用户请求，为了提高系统的效率，HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。但是，这也造成了一些性能上的缺陷，例如，一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的URL地址，当WEB浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析WEB服务器返回的该网页文档中的HTML内容时，发现其中的&lt;img&gt;图像标签后，浏览器将根据&lt;img&gt;标签中的src属性所指定的URL地址再次向服务器发出下载图像数据的请求。
显然，访问一个包含有许多图像的网页文件的整个过程包含了多次请求和响应，每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个文档和图像，上一次和下一次请求完全分离。即使图像文件都很小，但是客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程，并且会严重影响客户机和服务器的性能。当一个网页文件中包含 Applet，JavaScript文件，CSS文件等内容时，也会出现类似上述的情况。
为了克服HTTP 1.0的这个缺陷，HTTP 1.1支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。基于HTTP 1.1协议的客户机与服务器的信息交换过程。

### TCP三次握手和四次挥手的流程
![](/img/后台研发知识点总结/tcp1.png)

![](/img/后台研发知识点总结/tcp2.png)


### 为什么建立连接要进行3次握手,而断开连接要进行4次
TCP建立连接要进行3次握手,而断开连接要进行4次,这是由于TCP的半关闭造成的,因为TCP连接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭,这个单方向的关闭就叫半关闭.
关闭的方法是一方完成它的数据传输后,就发送一个FIN来向另一方通告将要终止这个方向的连接.当一端收到一个FIN,它必须通知应用层TCP连接已终止了这个方向的数据传送,发送FIN通常是应用层进行关闭的结果.

### 为什么不能两次握手进行连接？
现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。


### 说说你知道的几种HTTP响应码 

1XX Informational（信息性状态码）接收的请求正在处理
2XX Success（成功状态码） 请求正常处理完毕
3XX Redirection（重定向状态码） 需要进行附加操作以完成请求
4XX Client Error（客户端错误状态码）服务器无法处理请求
5XX Server Error（服务器错误状态码）服务器处理请求出错

200：请求被正常处理
204：请求被受理但没有资源可以返回
206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。
301：永久性重定向
302：临时重定向
303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
304：发送附带条件的请求时，条件不满足时返回，与重定向无关
307：临时重定向，与302类似，只是强制要求使用POST方法
400：请求报文语法有误，服务器无法识别
401：请求需要认证
403：请求的对应资源禁止被访问
404：服务器无法找到对应资源
500：服务器内部错误
503：服务器正忙




## 数据库


### 数据库事务ACID?
1. A: 原子性：指事务的所有操作要么全部成功，要么全部失败回滚。
2. C: 一致性：指事务必须使得数据库从一个一致性状态变换到另一个一致性状态，举个例子，银行转账，无论是用户a转钱给用户b，还是用户b转钱给用户a，两个人的总钱数不能发生变化。
3. I: 隔离性：指当多个用户访问数据库的时候，数据库为每一个用户开启的事务不能被其他事务干扰，多个并发事务之间要相互隔离。
4. D：持久性：指当事务完成之后，该事务对数据库所作的更改便持久化的保存在数据库中，并不会回滚。

### 数据库脏读，幻读，不可重复读都是什么？

1. 脏读(**多次写中间被读**)
    脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。
    　　当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。
2. 不可重复读(**多次读中间被写**)
    不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。

3. 幻读(**一批数据整体**)
    幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。
    　　幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。


### MySQL数据库隔离级别有哪几种
1. Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。
2. Repeatable read (可重复读)：可避免脏读、不可重复读的发生。
3. Read committed (读已提交)：可避免脏读的发生。
4. Read uncommitted (读未提交)：最低级别，任何情况都无法保证。

**<font color = red>一般数据库默认的隔离级别是Read committed (读已提交)， 但是MySQL是个例外，默认隔离级别是Repeatable read (可重复读)</font>**

### MySQL四种隔离级别是怎么实现的？

1. Read uncommitted(未授权读取、读未提交)：
   如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。
   避免了更新丢失，却可能出现脏读。也就是说事务B读取到了事务A未提交的数据。
2. Read committed（授权读取、读提交）：
   读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。
   该隔离级别避免了脏读，但是却可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。
3. Repeatable read（可重复读取）：
   读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。
   避免了不可重复读取和脏读，但是有时可能出现幻读。这可以通过“共享读锁”和“排他写锁”实现。
4. Serializable（序列化）：
   提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。
   序列化是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。


### 什么情况下使用缓存

对于内容变换缓慢或者不太重要，但又需要频繁查询数据库或从源头计算的中间结果或最终结果，我们可以采取使用缓存的方法，将其写到缓存中，每次使用时，只要缓存有效，就可直接使用缓存，不用再到数据库中取或重新计算

### 数据库左外连接和右外连接有什么区别？

左连接是以左边表中的数据为基准，如果左表中有数据，右表中没有数据，则显示：左表中的数据    右表中的数据(为空)
换句话说，左连接的结果集包括left子句中指定的左表的所有行，而不仅仅是连接匹配到的行，**如果左表中的某行在右表中没有匹配行，则在结果集中相关联列有关右表的列均为空值(因为没有匹配行)**
右连接则正好相反，如果右表的某行在左表中没有匹配行，则左表返回空值

### 主键和unique的区别

1. 主键一定是唯一性索引，唯一性索引并不一定就是主键；
2. 一个表中可以有多个唯一性索引，但只能有一个主键；
3. 主键列不允许空值，而唯一性索引列允许空值。

## Redis&缓存相关

### Redis的数据淘汰策略
在 Redis 中，允许用户设置最大使用内存大小 server.maxmemory, redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。redis 提供 6种数据淘汰策略：
1. volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
5. allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
6. no-enviction（驱逐）：禁止驱逐数据

redis 确定驱逐某个键值对后，会删除这个数据并，并将这个数据变更消息发布到本地（AOF 持久化）和从机（主从连接）。



## Linux

### 如何查找一个进程
使用**ps**命令可以查看进程状态
**ps -ef**可以查看所有进程，配合**grep**命令可以进行筛选，如查看tomcat进程的命令: **ps -ef | grep tomcat **

## 设计模式

### 在装饰器模式和代理模式之间，你如何抉择
装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。

## 常见算法题

## 工程实践

### 后台系统怎么防止请求重复提交？
首先我们在进入表单填写页面时，在服务器端生成一个唯一的随机标识号，专业术语称为Token(令牌)，同时在当前用户的Session域中保存这个Token。然后将Token发送到客户端的Form表单中，在Form表单中使用隐藏域来存储这个Token，表单提交的时候连同这个Token一起提交到服务器端，然后在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致，如果不一致，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。如果相同则处理表单提交，并清除当前用户的Session域中存储的标识号。
在下列情况下，服务器程序将拒绝处理用户提交的表单请求：
1. 存储Session域中的Token(令牌)与表单提交的Token(令牌)不同。
2. 当前用户的Session中不存在Token(令牌)。
3. 用户提交的表单数据中没有Token(令牌)。
 **<font color = red>需要注意的是当比对成功后，必须立即将该Session的值设置为空，这样才可保证页面再次POST时表单中的校验串就无法于Session中的空值比对成功。</font>**




